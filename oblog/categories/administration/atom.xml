<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Administration | Postgres and other musings]]></title>
  <link href="http://gurjeet.singh.im/blog/categories/administration/atom.xml" rel="self"/>
  <link href="http://gurjeet.singh.im/blog/"/>
  <updated>2014-07-23T23:03:27+00:00</updated>
  <id>http://gurjeet.singh.im/blog/</id>
  <author>
    <name><![CDATA[Gurjeet Singh]]></name>
    <email><![CDATA[gurjeet@singh.im]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Hibernating and Restoring Postgres Buffer Cache]]></title>
    <link href="http://gurjeet.singh.im/blog/2014/01/21/hibernating-and-restoring-postgres-buffer-cache/"/>
    <updated>2014-01-21T03:01:45+00:00</updated>
    <id>http://gurjeet.singh.im/blog/2014/01/21/hibernating-and-restoring-postgres-buffer-cache</id>
    <content type="html"><![CDATA[<p>With the introduction of <a href="http://git.postgresql.org/gitweb/?p=postgresql.git;a=commitdiff;h=c32afe53c2e87a56e2ff930798a5588db0f7a516"><code>pg_prewarm</code></a> extension in Postgres,
it has become very easy to save and restore the contents of Postgres server&rsquo;s
buffer cache across a server restart. The tables, indexes and other on-disk data
structures (like <a href="http://www.postgresql.org/docs/9.3/static/storage-toast.html">TOAST</a> data, Visibility Map, etc.) are cached in
shared-buffers before they can be read or modified by user queries. Hence, by
saving the shared-buffers before a server restart, and restoring those buffers
after the restart, you can expect to reduce the ramp-up time, and hence expect
peak performance almost right off the bat.</p>

<p>Following is a brain-dead way of implementing hibernation, and I am sure it can
be optimized to reduce the number of calls to <code>pg_prewarm</code>, since it allows the
caller to specify a range of blocks to be loaded, and I&rsquo;m asking it to load just
one block per call.</p>

<p>We&rsquo;re going to use <a href="http://www.postgresql.org/docs/9.3/static/pgbuffercache.html"><code>pg_buffercache</code></a> to extract the list of
buffers currently loaded in buffer cache, and after a server restart, <code>pg_prewarm</code>
will be used to load those buffers back in.</p>

<h2>Declare environment variables to be used by scripts</h2>

<pre><code>HIBERNATE_DESTINATION=$HOME/pg_hibernate/

export PGUSER=postgres
PSQL="psql"
PSQL_TEMPL_DB="$PSQL -d template1"
PSQL_PG_DB="$PSQL -d postgres"

PSQL_TEMPL_NOFLUFF="$PSQL_TEMPL_DB -A -t"
PSQL_PG_NOFLUFF="$PSQL_PG_DB -A -t"
</code></pre>

<h2>Prepare the databases</h2>

<p>This is a one time operation. We avoid installing anything into <code>template0</code>
database, since it is a read-only database. But we do consciously install the
extension into <code>template1</code> database; this is so that any new databases created
after this point will get this extension pre-installed.</p>

<h3>Install extensions</h3>

<pre><code>for db in $($PSQL_TEMPL_NOFLUFF -c 'select datname from pg_database where datname &lt;&gt; $$template0$$'); do
  echo Installing pg_prewarm in $db
  $PSQL_TEMPL_DB -c 'create extension if not exists pg_prewarm;'
done

echo Installing pg_buffercache extension in postgres database
$PSQL_PG_DB -c 'create extension if not exists pg_buffercache;'
</code></pre>

<h2>Save buffer information</h2>

<p>We are actually generating a <code>psql</code> script, that can be later fed to <code>psql</code>, as is.</p>

<pre><code>mkdir -p $HIBERNATE_DESTINATION

for db in $($PSQL_TEMPL_NOFLUFF -c 'select datname from pg_database where datname &lt;&gt; $$template0$$'); do
  $PSQL_PG_NOFLUFF -c 'select    $q$select pg_prewarm((    select    oid
                                                         from      pg_class
                                                         where     pg_relation_filenode(oid) = $q$ || relfilenode || $q$)::regclass,
                                                     $$buffer$$, $q$
                                                     || case relforknumber
                                                        when 0 then $q$$$main$$$q$
                                                        when 1 then $q$$$fsm$$$q$
                                                        when 2 then $q$$$vm$$$q$
                                                        when 3 then $q$$$init$$$q$
                                                        end || $q$, $q$
                                                     || relblocknumber || $q$, $q$
                                                     || relblocknumber || $q$);$q$
                                    from     pg_buffercache
                                    where    reldatabase = (select    oid
                                                            from      pg_database
                                                            where     datname = $$'${db}'$$)
                                    order by relfilenode, relforknumber, relblocknumber;' &gt; $HIBERNATE_DESTINATION/${db}.save
done
</code></pre>

<h2>Restore the buffers</h2>

<p>Ideally, this would be performed after a server restart, but there&rsquo;s no harm in
doing it without the restart either (except the performance implications, if
doing this eveicts buffers currently in use by other connections ;). Note that
if some table/index&rsquo;s underlying file storage has been renamed by the server
since we extracted the buffers list, some of these calls will return with <code>ERROR</code>.</p>

<p>We connect to each database, and simply feed the script generated earlier, into <code>psql</code>.</p>

<pre><code>for db in $($PSQL_TEMPL_NOFLUFF -c 'select datname from pg_database where datname &lt;&gt; $$template0$$'); do
  if [ ! -e $HIBERNATE_DESTINATION/${db}.save ]; then
    continue
  fi
  $PSQL -d $db -f $HIBERNATE_DESTINATION/${db}.save
done
</code></pre>

<p>At this point, the Postgres shared-buffers should contain all the buffers that
were present when we extracted the buffer list from <code>pg_buffercache</code>.</p>

<p>PS: When reviewing the <code>pg_prewarm</code> code, I did not think through the user-experience
aspect of this extension. But after it was committed, the more I thought about
how it&rsquo;s going to be used, the less appealing this solution became. As is evident
from above, the administrator needs the help of two extensions, and then a storage
location where to store the list of buffers. Ideally, as a DBA, I would like to
see a feature which doesn&rsquo;t require me to muck around with catalogs etc. I have
a design for such an extension, and may start coding it some time soon.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Understanding Postgres Parameter Context]]></title>
    <link href="http://gurjeet.singh.im/blog/2014/01/07/understanding-postgres-parameter-context/"/>
    <updated>2014-01-07T21:55:21+00:00</updated>
    <id>http://gurjeet.singh.im/blog/2014/01/07/understanding-postgres-parameter-context</id>
    <content type="html"><![CDATA[<p>Postgres' parameters have an associated context, which determines when that
parameter can be changed.</p>

<p>You can see the context of every parameter using the following query. A sample
output is also shown.</p>

<pre><code>select name, context from pg_settings order by category;

              name               |  context   
---------------------------------+------------
 autovacuum_freeze_max_age       | postmaster
 autovacuum_max_workers          | postmaster
 autovacuum_vacuum_threshold     | sighup
 ...
 IntervalStyle                   | user
 ...
 server_encoding                 | internal
 ...
 lc_messages                     | superuser
 ...
 local_preload_libraries         | backend
 ...
</code></pre>

<p>The possible values of context are:</p>

<ul>
<li>internal (called <code>PGC_INTERNAL</code> in source code)</li>
<li>postmaster (<code>PGC_POSTMASTER</code>)</li>
<li>sighup (<code>PGC_SIGHUP</code>)</li>
<li>backend (<code>PGC_BACKEND</code>)</li>
<li>superuser (<code>PGC_SUSET</code>)</li>
<li>user (<code>PGC_USERSET</code>)</li>
</ul>


<p>The above list is in order of when a parameter can be set; if a parameter can be
changed in a certain context, then it can be changed at any of the earlier
contexts as well.</p>

<h3>internal</h3>

<p>The <code>internal</code> parameters cannot be changed; these are usually compile-time
constants. If you want to change any of these, you&rsquo;ll have to change it in
Postgres source code and compile a new set of Postgres executables.</p>

<h3>postmaster</h3>

<p>The <code>postmaster</code> parameters can be set at Postgres startup, or during source code
compilation. (Postmaster is the parent process of all the Postgres processes,
hence the context&rsquo;s name).</p>

<p>These parameters can be set in the <code>postgresql.conf</code> file or on the command-line
when starting the Postgres server.</p>

<h3>sighup</h3>

<p>The <code>sighup</code> parameters can be changed while the server is running, at Postgres
startup, or during code compilation.</p>

<p>To change such a parameter, you can change it in the <code>postgresql.conf</code> file and send a
<code>SIGHUP</code> signal to the Postmaster process. An easy way to send the <code>SIGHUP</code> signal
to the Postmaster process is to use <code>pg_ctl</code> or your distribution&rsquo;s Postgres-init
script, like so:</p>

<pre><code>pg_clt -D $PGDATA reload
</code></pre>

<p>OR</p>

<pre><code>sudo service postgresql-9.3 reload
</code></pre>

<h3>backend</h3>

<p>The <code>backend</code> parameters can be changed/set while making a new connection to
Postgres, and never after that (and these can be changed by <code>SIGHUP</code>, at Postgres
startup, or during code compilation).</p>

<p>Usually the applications set these parameters while making the initial connection.</p>

<p>An example is the <code>local_preload_libraries</code> parameter. Say, if you want to try a
plugin for just one session, then you can initiate a <code>psql</code> session, with that
plugin loaded for the connection, like so:</p>

<pre><code>PGOPTIONS="-c local_preload_libraries=my_plugin" psql
</code></pre>

<p>The above method of changing parameters is possible for any application that
uses <code>libpq</code> library to connect to Postrges (for eg. <a href="http://pgadmin.org/">pgAdmin</a>), since the <code>PGOPTIONS</code>
environment variable is recognized and honored by <code>libpq</code>. Other applications/libraries
may have their own methods to allow changing parameters during connection initiation.</p>

<h3>superuser</h3>

<p>To change a <code>superuser</code> parameter, one needs to have <code>superuser</code> privileges in Postgres.
These parameters can be changed while a session is in progress, during a backend
startup, using <code>SIGHUP</code>, at Postgres startup, or during code compilation.</p>

<p>Note that normal users cannot change these parameters.</p>

<h3>user</h3>

<p>The parameters with <code>user</code> context can be changed by any user, at any time, to
affect the current session they are connected to. Needless to say that since this
is the last context in the list, a parameter that is marked as <code>user</code> context, can be changed
using any of the methods shown for the other contexts.</p>

<p>The <code>SET</code> command can be used to change a <code>user</code> context parameter&rsquo;s value, for eg.:</p>

<pre><code>SET work_mem = '32 MB';
</code></pre>

<h2>Using context in queries</h2>

<p>Although, as explained above, there is a certain order in the values of <code>context</code>,
there is no built-in way for one to see this order, and exploit that knowledge
using queries.</p>

<p>Say, if one wants to see a list of all parameters that cannot be
changed by a normal user, there&rsquo;s no straightforward way to do it. To that end,
I create the following <code>enum</code> type and use it in queries to extract that information easily:</p>

<pre><code>create type guc_context as enum (
    'internal',
    'postmaster',
    'sighup',
    'backend',
    'superuser',
    'user');

select name as cannot_be_changed_by_user, context
from pg_settings
where context::guc_context &lt; 'user';
</code></pre>

<p>Other useful information that can now be easily extracted using this <code>enum</code>:</p>

<pre><code>select name as parameter,
    context_enum &gt; 'internal' as can_be_changed,
    context_enum = 'postmaster' as change_requires_restart,
    context_enum &gt;= 'sighup' as can_be_changed_by_reload
from (select name, context::guc_context as context_enum
    from pg_settings) as v;

            parameter            | can_be_changed | change_requires_restart | can_be_changed_by_reload 
---------------------------------+----------------+-------------------------+--------------------------
 allow_system_table_mods         | t              | t                       | f
 application_name                | t              | f                       | t
 archive_command                 | t              | f                       | t
 archive_mode                    | t              | t                       | f
 archive_timeout                 | t              | f                       | t
 array_nulls                     | t              | f                       | t
 authentication_timeout          | t              | f                       | t
 ...
</code></pre>
]]></content>
  </entry>
  
</feed>
